"""
GitHub-flavored markdown formatter for Socket Security Basics.

This module provides markdown formatting functionality for GitHub PR comments,
converting security findings into markdown tables and sections.
"""

from typing import Any, List
from .base import TableFormatter

# GitHub comment limits
MAX_COMMENT_LENGTH = 60000  # Conservative limit (GitHub allows ~65KB)


class MarkdownFormatter(TableFormatter):
    """Formatter for GitHub-flavored markdown content."""
    
    def __init__(self):
        super().__init__(max_content_length=MAX_COMMENT_LENGTH)
    
    def format_findings(self, findings: List[dict], title: str = "Security Findings") -> str:
        """Format security findings as a markdown table.
        
        Args:
            findings: List of finding dictionaries
            title: Title for the formatted content
            
        Returns:
            Formatted markdown table
        """
        if not findings:
            return f"## {title}\n\nNo findings to report."
        
        # Standard columns for security findings
        columns = ['Component', 'Severity', 'Issue', 'File', 'Line']
        table_content = self.format_findings_as_table(findings, columns, title)
        
        return self.truncate_content(table_content)
    
    def format_table(self, headers: List[str], rows: List[List[Any]], title: str = "Results") -> str:
        """Format tabular data as a markdown table.
        
        Args:
            headers: Column headers
            rows: Table rows as lists of values
            title: Title for the formatted table
            
        Returns:
            Formatted markdown table
        """
        if not rows:
            return f"## {title}\n\nNo data to display."
        
        # Sanitize cells for markdown
        sanitized_rows = []
        for row in rows:
            sanitized_row = [self._sanitize_cell_for_markdown(cell) for cell in row]
            sanitized_rows.append(sanitized_row)
        
        # Build markdown table
        output_lines = []
        
        # Title as H2
        output_lines.append(f"## {title}")
        output_lines.append("")
        
        # Header row
        header_row = "| " + " | ".join(headers) + " |"
        output_lines.append(header_row)
        
        # Header separator
        separator = "|" + "|".join([" --- " for _ in headers]) + "|"
        output_lines.append(separator)
        
        # Data rows
        for row in sanitized_rows:
            data_row = "| " + " | ".join(str(cell) for cell in row) + " |"
            output_lines.append(data_row)
        
        return "\n".join(output_lines)
    
    def _sanitize_cell_for_markdown(self, cell: Any) -> str:
        """Sanitize table cell values for markdown display.
        
        Args:
            cell: The cell value to sanitize
            
        Returns:
            Sanitized string suitable for markdown table
        """
        cell_str = self.sanitize_text(cell)
        
        # Escape markdown special characters in table cells
        cell_str = cell_str.replace("|", "\\|")
        cell_str = cell_str.replace("\n", "<br>")
        
        # Limit cell length for readability
        if len(cell_str) > 200:
            cell_str = cell_str[:197] + "..."
        
        return cell_str


def build_markdown_from_notifications(notifications: List[dict]) -> str:
    """Build GitHub-flavored markdown from notification data.
    
    Args:
        notifications: List of dicts with 'title' and 'content' keys
        
    Returns:
        Complete markdown string with sections separated by horizontal rules
    """
    if not notifications:
        return "No security findings to report."
    
    markdown_sections = []
    for item in notifications:
        if not isinstance(item, dict):
            continue
            
        title = item.get('title', 'Untitled')
        content = item.get('content', 'No content')
        
        # Format as markdown section with H3 header
        markdown_sections.append(f"### {title}\n\n{content}")
    
    return '\n\n---\n\n'.join(markdown_sections)


def create_pr_comment_body(markdown_content: str, uid: str, footer: str = "Generated by Socket Security") -> str:
    """Create a complete PR comment body with marker and footer.
    
    Args:
        markdown_content: Main markdown content
        uid: Unique identifier for comment tracking
        footer: Footer text
        
    Returns:
        Complete PR comment body with tracking markers
    """
    return f"""<!-- {uid} -->
{markdown_content}

---
*{footer}*
<!-- /{uid} -->"""